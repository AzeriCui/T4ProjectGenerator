// ------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本: 12.0.0.0
//  
//     对此文件的更改可能会导致不正确的行为。此外，如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
// ------------------------------------------------------------------------------
namespace T4ProjectGenerator
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "E:\zy\T4\T4ProjectGenerator\T4ProjectGenerator\Template\Common\Expr.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "12.0.0.0")]
    public partial class Expr : Base
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("using Dapper;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Lin" +
                    "q.Expressions;\r\nusing System.Reflection;\r\nusing System.Text;\r\n\r\nnamespace ");
            
            #line 13 "E:\zy\T4\T4ProjectGenerator\T4ProjectGenerator\Template\Common\Expr.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(Config.CommonNamespace));
            
            #line default
            #line hidden
            this.Write("\r\n{\r\n    public abstract class Expr\r\n    {\r\n        public Expr() { }\r\n\r\n        " +
                    "protected string Name { get; set; }\r\n        protected object Value { get; set; " +
                    "}\r\n        protected string Join { get; set; }\r\n\r\n        public virtual string " +
                    "ToWhere(DynamicParameters parameters)\r\n        {\r\n            if (parameters == " +
                    "null)\r\n            {\r\n                throw new ArgumentNullException(\"parameter" +
                    "s\", \"操作参数容器不能为空\");\r\n            }\r\n            parameters.Add(this.Name, this.Va" +
                    "lue);\r\n            return string.Format(\" {0} {1} @{0} \", this.Name, this.Join);" +
                    "\r\n        }\r\n\r\n        private static string GetExprName<TSource, TResult>(Expre" +
                    "ssion<Func<TSource, TResult>> exprName)\r\n        {\r\n            MemberExpression" +
                    " memberExpr = exprName.Body as MemberExpression;\r\n            if (memberExpr == " +
                    "null)\r\n            {\r\n                throw new ArgumentNullException(\"exprName\"" +
                    ", \"表达式不正确\");\r\n            }\r\n            PropertyInfo property = memberExpr.Memb" +
                    "er as PropertyInfo;\r\n            if (property == null)\r\n            {\r\n         " +
                    "       throw new ArgumentNullException(\"property\", \"表达式不正确\");\r\n            }\r\n  " +
                    "          return property.Name;\r\n        }\r\n\r\n        public static Expr And(par" +
                    "ams Expr[] exprs)\r\n        {\r\n            return new AndExpr(exprs);\r\n        }\r" +
                    "\n\r\n        public static Expr Or(params Expr[] exprs)\r\n        {\r\n            re" +
                    "turn new OrExpr(exprs);\r\n        }\r\n\r\n        public static Expr Equal<TSource, " +
                    "TResult>(Expression<Func<TSource, TResult>> exprName, object value)\r\n        {\r\n" +
                    "            string name = GetExprName<TSource, TResult>(exprName);\r\n            " +
                    "return new EqualExpr(name, value);\r\n        }\r\n\r\n        public static Expr NotE" +
                    "qual<TSource, TResult>(Expression<Func<TSource, TResult>> exprName, object value" +
                    ")\r\n        {\r\n            string name = GetExprName<TSource, TResult>(exprName);" +
                    "\r\n            return new NotEqualExpr(name, value);\r\n        }\r\n\r\n        public" +
                    " static Expr Like<TSource, TResult>(Expression<Func<TSource, TResult>> exprName," +
                    " object value)\r\n        {\r\n            string name = GetExprName<TSource, TResul" +
                    "t>(exprName);\r\n            return new LikeExpr(name, value);\r\n        }\r\n\r\n     " +
                    "   public static Expr NotLike<TSource, TResult>(Expression<Func<TSource, TResult" +
                    ">> exprName, object value)\r\n        {\r\n            string name = GetExprName<TSo" +
                    "urce, TResult>(exprName);\r\n            return new NotLikeExpr(name, value);\r\n   " +
                    "     }\r\n\r\n        public static Expr GreaterThan<TSource, TResult>(Expression<Fu" +
                    "nc<TSource, TResult>> exprName, object value)\r\n        {\r\n            string nam" +
                    "e = GetExprName<TSource, TResult>(exprName);\r\n            return new GreaterThan" +
                    "Expr(name, value);\r\n        }\r\n\r\n        public static Expr GreaterThanEqual<TSo" +
                    "urce, TResult>(Expression<Func<TSource, TResult>> exprName, object value)\r\n     " +
                    "   {\r\n            string name = GetExprName<TSource, TResult>(exprName);\r\n      " +
                    "      return new GreaterThanEqualExpr(name, value);\r\n        }\r\n\r\n        public" +
                    " static Expr LessThan<TSource, TResult>(Expression<Func<TSource, TResult>> exprN" +
                    "ame, object value)\r\n        {\r\n            string name = GetExprName<TSource, TR" +
                    "esult>(exprName);\r\n            return new LessThanExpr(name, value);\r\n        }\r" +
                    "\n\r\n        public static Expr LessThanEqual<TSource, TResult>(Expression<Func<TS" +
                    "ource, TResult>> exprName, object value)\r\n        {\r\n            string name = G" +
                    "etExprName<TSource, TResult>(exprName);\r\n            return new LessThanEqualExp" +
                    "r(name, value);\r\n        }\r\n\r\n        public static Expr Between<TSource, TResul" +
                    "t>(Expression<Func<TSource, TResult>> exprName, object minValue, object maxValue" +
                    ")\r\n        {\r\n            string name = GetExprName<TSource, TResult>(exprName);" +
                    "\r\n            return new BetweenExpr(name, minValue, maxValue);\r\n        }\r\n\r\n  " +
                    "      public static Expr In<TSource, TResult>(Expression<Func<TSource, TResult>>" +
                    " exprName, params object[] values)\r\n        {\r\n            string name = GetExpr" +
                    "Name<TSource, TResult>(exprName);\r\n            return new InExpr(name, values);\r" +
                    "\n        }\r\n\r\n        public static Expr NotIn<TSource, TResult>(Expression<Func" +
                    "<TSource, TResult>> exprName, params object[] values)\r\n        {\r\n            st" +
                    "ring name = GetExprName<TSource, TResult>(exprName);\r\n            return new Not" +
                    "InExpr(name, values);\r\n        }\r\n\r\n\r\n        public static Expr Equal(string na" +
                    "me, object value)\r\n        {\r\n            return new EqualExpr(name, value);\r\n  " +
                    "      }\r\n\r\n        public static Expr NotEqual(string name, object value)\r\n     " +
                    "   {\r\n            return new NotEqualExpr(name, value);\r\n        }\r\n\r\n        pu" +
                    "blic static Expr Like(string name, object value)\r\n        {\r\n            return " +
                    "new LikeExpr(name, value);\r\n        }\r\n\r\n        public static Expr NotLike(stri" +
                    "ng name, object value)\r\n        {\r\n            return new NotLikeExpr(name, valu" +
                    "e);\r\n        }\r\n\r\n        public static Expr GreaterThan(string name, object val" +
                    "ue)\r\n        {\r\n            return new GreaterThanExpr(name, value);\r\n        }\r" +
                    "\n\r\n        public static Expr GreaterThanEqual(string name, object value)\r\n     " +
                    "   {\r\n            return new GreaterThanEqualExpr(name, value);\r\n        }\r\n\r\n  " +
                    "      public static Expr LessThan(string name, object value)\r\n        {\r\n       " +
                    "     return new LessThanExpr(name, value);\r\n        }\r\n\r\n        public static E" +
                    "xpr LessThanEqual(string name, object value)\r\n        {\r\n            return new " +
                    "LessThanEqualExpr(name, value);\r\n        }\r\n\r\n        public static Expr Between" +
                    "(string name, object minValue, object maxValue)\r\n        {\r\n            return n" +
                    "ew BetweenExpr(name, minValue, maxValue);\r\n        }\r\n\r\n        public static Ex" +
                    "pr In(string name, params object[] values)\r\n        {\r\n            return new In" +
                    "Expr(name, values);\r\n        }\r\n\r\n        public static Expr NotIn(string name, " +
                    "params object[] values)\r\n        {\r\n            return new NotInExpr(name, value" +
                    "s);\r\n        }\r\n    }\r\n\r\n    internal class AndExpr : ExprCollection\r\n    {\r\n   " +
                    "     public AndExpr(params Expr[] exprs) : base(\"AND\", exprs) { }\r\n    }\r\n\r\n    " +
                    "internal class AscExpr : OrderByExpr\r\n    {\r\n        public AscExpr(string name)" +
                    "\r\n            : base(name, \"ASC\")\r\n        { }\r\n    }\r\n\r\n    internal class Betw" +
                    "eenExpr : Expr\r\n    {\r\n        protected object MinValue { get; set; }\r\n        " +
                    "protected object MaxValue { get; set; }\r\n        public BetweenExpr(string name," +
                    " object minValue, object maxValue)\r\n        {\r\n            this.Name = name;\r\n  " +
                    "          this.MinValue = minValue;\r\n            this.MaxValue = maxValue;\r\n    " +
                    "    }\r\n\r\n        public override string ToWhere(DynamicParameters parameters)\r\n " +
                    "       {\r\n            if (parameters == null)\r\n            {\r\n                th" +
                    "row new ArgumentNullException(\"parameters\", \"操作参数容器不能为空\");\r\n            }\r\n     " +
                    "       string nameMin = string.Format(\"@{0}Min\", this.Name);\r\n            string" +
                    " nameMax = string.Format(\"@{0}Max\", this.Name);\r\n            parameters.Add(name" +
                    "Min, this.MinValue);\r\n            parameters.Add(nameMax, this.MaxValue);\r\n     " +
                    "       return string.Format(\" {0} BETWEEN {1} AND {0} \", this.Name, nameMin, nam" +
                    "eMax);\r\n        }\r\n    }\r\n\r\n    internal class DescExpr : OrderByExpr\r\n    {\r\n  " +
                    "      public DescExpr(string name)\r\n            : base(name, \"DESC\")\r\n        { " +
                    "}\r\n    }\r\n\r\n    internal class EqualExpr : Expr\r\n    {\r\n        public EqualExpr" +
                    "(string name, object value)\r\n        {\r\n            this.Name = name;\r\n         " +
                    "   this.Value = value;\r\n            this.Join = \"=\";\r\n        }\r\n    }\r\n\r\n    in" +
                    "ternal abstract class ExprCollection : Expr\r\n    {\r\n        protected IList<Expr" +
                    "> ExprList { get; set; }\r\n\r\n        public ExprCollection(string join, params Ex" +
                    "pr[] exprs)\r\n        {\r\n            this.Join = join;\r\n            this.ExprList" +
                    " = new List<Expr>(exprs);\r\n        }\r\n\r\n        public override string ToWhere(D" +
                    "ynamicParameters parameters)\r\n        {\r\n            if (parameters == null)\r\n  " +
                    "          {\r\n                throw new ArgumentNullException(\"parameters\", \"操作参数" +
                    "容器不能为空\");\r\n            }\r\n            StringBuilder builder = new StringBuilder(" +
                    ");\r\n            builder.Append(\"(\");\r\n            for (int i = 0; i < ExprList.C" +
                    "ount; i++)\r\n            {\r\n                builder.Append(ExprList[i].ToWhere(pa" +
                    "rameters));\r\n                if (i < ExprList.Count - 1)\r\n                {\r\n   " +
                    "                 builder.Append(this.Join);\r\n                }\r\n            }\r\n " +
                    "           builder.Append(\")\");\r\n            return builder.ToString();\r\n       " +
                    " }\r\n    }\r\n\r\n    internal class GreaterThanEqualExpr : Expr\r\n    {\r\n        publ" +
                    "ic GreaterThanEqualExpr(string name, object value)\r\n        {\r\n            this." +
                    "Name = name;\r\n            this.Value = value;\r\n            this.Join = \">=\";\r\n  " +
                    "      }\r\n    }\r\n\r\n    internal class GreaterThanExpr : Expr\r\n    {\r\n        publ" +
                    "ic GreaterThanExpr(string name, object value)\r\n        {\r\n            this.Name " +
                    "= name;\r\n            this.Value = value;\r\n            this.Join = \">\";\r\n        " +
                    "}\r\n    }\r\n\r\n    internal class InExpr : Expr\r\n    {\r\n        protected object[] " +
                    "Values { get; set; }\r\n        public InExpr(string name, params object[] values)" +
                    "\r\n        {\r\n            this.Name = name;\r\n            this.Values = values;\r\n " +
                    "           this.Join = \"IN\";\r\n        }\r\n\r\n        public override string ToWher" +
                    "e(DynamicParameters parameters)\r\n        {\r\n            if (parameters == null)\r" +
                    "\n            {\r\n                throw new ArgumentNullException(\"parameters\", \"操" +
                    "作参数容器不能为空\");\r\n            }\r\n            StringBuilder builder = new StringBuild" +
                    "er();\r\n            builder.Append(this.Name + \" IN (\");\r\n            for (int i " +
                    "= 0; i < Values.Length; i++)\r\n            {\r\n                parameters.Add(\"@\" " +
                    "+ this.Name + i, Values[i]);\r\n                builder.Append(\"@\" + this.Name + i" +
                    ");\r\n                if (i + 1 < Values.Length)\r\n                {\r\n             " +
                    "       builder.Append(\", \");\r\n                }\r\n            }\r\n            buil" +
                    "der.Append(\")\");\r\n            return builder.ToString();\r\n        }\r\n    }\r\n\r\n  " +
                    "  internal class LessThanEqualExpr : Expr\r\n    {\r\n        public LessThanEqualEx" +
                    "pr(string name, object value)\r\n        {\r\n            this.Name = name;\r\n       " +
                    "     this.Value = value;\r\n            this.Join = \"<=\";\r\n        }\r\n    }\r\n\r\n   " +
                    " internal class LessThanExpr : Expr\r\n    {\r\n        public LessThanExpr(string n" +
                    "ame, object value)\r\n        {\r\n            this.Name = name;\r\n            this.V" +
                    "alue = value;\r\n            this.Join = \"<\";\r\n        }\r\n    }\r\n\r\n    internal cl" +
                    "ass LikeExpr : Expr\r\n    {\r\n        public LikeExpr(string name, object value)\r\n" +
                    "        {\r\n            this.Name = name;\r\n            this.Value = value;\r\n     " +
                    "       this.Join = \"LIKE\";\r\n        }\r\n    }\r\n\r\n    internal class NotEqualExpr " +
                    ": Expr\r\n    {\r\n        public NotEqualExpr(string name, object value)\r\n        {" +
                    "\r\n            this.Name = name;\r\n            this.Value = value;\r\n            th" +
                    "is.Join = \"<>\";\r\n        }\r\n    }\r\n\r\n    internal class NotInExpr : Expr\r\n    {\r" +
                    "\n        protected object[] Values { get; set; }\r\n        public NotInExpr(strin" +
                    "g name, params object[] values)\r\n        {\r\n            this.Name = name;\r\n     " +
                    "       this.Values = values;\r\n            this.Join = \"NOT IN\";\r\n        }\r\n\r\n  " +
                    "      public override string ToWhere(DynamicParameters parameters)\r\n        {\r\n " +
                    "           if (parameters == null)\r\n            {\r\n                throw new Arg" +
                    "umentNullException(\"parameters\", \"操作参数容器不能为空\");\r\n            }\r\n            Stri" +
                    "ngBuilder builder = new StringBuilder();\r\n            builder.Append(this.Name +" +
                    " \" NOT IN (\");\r\n            for (int i = 0; i < Values.Length; i++)\r\n           " +
                    " {\r\n                parameters.Add(\"@\" + this.Name + i, Values[i]);\r\n           " +
                    "     builder.Append(\"@\" + this.Name + i);\r\n                if (i + 1 < Values.Le" +
                    "ngth)\r\n                {\r\n                    builder.Append(\", \");\r\n           " +
                    "     }\r\n            }\r\n            builder.Append(\")\");\r\n            return buil" +
                    "der.ToString();\r\n        }\r\n    }\r\n\r\n    internal class NotLikeExpr : Expr\r\n    " +
                    "{\r\n        public NotLikeExpr(string name, object value)\r\n        {\r\n           " +
                    " this.Name = name;\r\n            this.Value = value;\r\n            this.Join = \"NO" +
                    "T LIKE\";\r\n        }\r\n    }\r\n\r\n    internal class OrderByCollection : OrderByExpr" +
                    "\r\n    {\r\n        protected IList<OrderByExpr> OrderByList { get; set; }\r\n\r\n     " +
                    "   public OrderByCollection(params OrderByExpr[] exprs)\r\n            : base(null" +
                    ", null)\r\n        {\r\n            this.OrderByList = new List<OrderByExpr>(exprs);" +
                    "\r\n        }\r\n\r\n        public override string ToOrderBy()\r\n        {\r\n          " +
                    "  StringBuilder builder = new StringBuilder();\r\n            for (int i = 0; i < " +
                    "OrderByList.Count; i++)\r\n            {\r\n                builder.Append(OrderByLi" +
                    "st[i].ToOrderBy());\r\n                if (i < OrderByList.Count - 1)\r\n           " +
                    "     {\r\n                    builder.Append(\", \");\r\n                }\r\n          " +
                    "  }\r\n            return builder.ToString();\r\n        }\r\n    }\r\n\r\n    public abst" +
                    "ract class OrderByExpr\r\n    {\r\n        protected string Name { get; set; }\r\n    " +
                    "    protected string OrderBy { get; set; }\r\n\r\n        public OrderByExpr(string " +
                    "name, string orderBy)\r\n        {\r\n            this.Name = name;\r\n            thi" +
                    "s.OrderBy = orderBy;\r\n        }\r\n\r\n        public virtual string ToOrderBy()\r\n  " +
                    "      {\r\n            return this.Name + \" \" + this.OrderBy;\r\n        }\r\n\r\n      " +
                    "  public static OrderByExpr Asc<TSource, TResult>(Expression<Func<TSource, TResu" +
                    "lt>> exprName)\r\n        {\r\n            string name = GetExprName(exprName);\r\n   " +
                    "         return new AscExpr(name);\r\n        }\r\n\r\n        public static OrderByEx" +
                    "pr Desc<TSource, TResult>(Expression<Func<TSource, TResult>> exprName)\r\n        " +
                    "{\r\n            string name = GetExprName(exprName);\r\n            return new Desc" +
                    "Expr(name);\r\n        }\r\n\r\n        public static OrderByExpr Asc(string name)\r\n  " +
                    "      {\r\n            return new AscExpr(name);\r\n        }\r\n\r\n        public stat" +
                    "ic OrderByExpr Desc(string name)\r\n        {\r\n            return new DescExpr(nam" +
                    "e);\r\n        }\r\n\r\n        public static OrderByExpr OrderByJoin(params OrderByEx" +
                    "pr[] exprs)\r\n        {\r\n            if (exprs == null)\r\n            {\r\n         " +
                    "       throw new ArgumentNullException(\"exprs\", \"表达式不能为空\");\r\n            }\r\n    " +
                    "        return new OrderByCollection(exprs);\r\n        }\r\n\r\n        private stati" +
                    "c string GetExprName<TSource, TResult>(Expression<Func<TSource, TResult>> exprNa" +
                    "me)\r\n        {\r\n            MemberExpression memberExpr = exprName.Body as Membe" +
                    "rExpression;\r\n            if (memberExpr == null)\r\n            {\r\n              " +
                    "  throw new ArgumentNullException(\"exprName\", \"表达式不正确\");\r\n            }\r\n       " +
                    "     PropertyInfo property = memberExpr.Member as PropertyInfo;\r\n            if " +
                    "(property == null)\r\n            {\r\n                throw new ArgumentNullExcepti" +
                    "on(\"property\", \"表达式不正确\");\r\n            }\r\n            return property.Name;\r\n   " +
                    "     }\r\n    }\r\n\r\n    internal class OrExpr : ExprCollection\r\n    {\r\n        publ" +
                    "ic OrExpr(params Expr[] exprs) : base(\"OR\", exprs) { }\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
}
